import { Service, OnInit } from "@flamework/core";
import { MarketplaceService, Players } from "@rbxts/services";
import { DataService } from "@server/services/data.service";
import { DATA_CONSTANTS } from "@shared/constants/data-constants";

const version = { major: 1, minor: 0, patch: 0 };

export type ProductCallback = (player: Player, productId: number) => boolean;

export interface ReceiptInfo {
	PlayerId: number;
	ProductId: number;
	PurchaseId: string;
	CurrencySpent: number;
	CurrencyType: Enum.CurrencyType;
}

/**
 * Receipt processor service for handling in-game purchases and developer products.
 * Ensures purchases are processed exactly once and properly recorded.
 */
@Service()
export class ReceiptProcessorService implements OnInit {
	public readonly version = version;

	// Product callbacks registry
	private productCallbacks: Map<number, ProductCallback> = new Map();

	// Receipt processing constants
	private readonly MAX_RECEIPT_HISTORY = DATA_CONSTANTS.MAX_RECEIPT_HISTORY;

	constructor(private readonly dataService: DataService) {}

	public onInit(): void {
		this.setupMarketplaceService();
		print("ReceiptProcessorService initialized");
	}

	/**
	 * Registers a callback for a developer product
	 */
	public registerProductCallback(developerProductId: number, productCallback: ProductCallback): void {
		if (this.productCallbacks.has(developerProductId)) {
			error(`Developer product ${developerProductId} already has a callback assigned`);
		}
		this.productCallbacks.set(developerProductId, productCallback);
		print(`Registered product callback for developer product ${developerProductId}`);
	}

	/**
	 * Unregisters a callback for a developer product
	 */
	public unregisterProductCallback(developerProductId: number): void {
		this.productCallbacks.delete(developerProductId);
		print(`Unregistered product callback for developer product ${developerProductId}`);
	}

	/**
	 * Gets all registered product IDs
	 */
	public getRegisteredProductIds(): number[] {
		const ids: number[] = [];
		for (const [productId] of this.productCallbacks) {
			ids.push(productId);
		}
		return ids;
	}

	/**
	 * Processes a receipt for a player
	 */
	public async processReceiptAsync(
		playerId: number,
		productId: number,
		purchaseId: string,
	): Promise<Enum.ProductPurchaseDecision> {
		print(`Processing receipt: Player ${playerId}, Product ${productId}, Purchase ${purchaseId}`);

		// We do not want to save player data if the player is not currently in the server
		const player = Players.GetPlayerByUserId(playerId);
		if (!player) {
			warn(`Player ${playerId} not found in server, deferring receipt processing`);
			return Enum.ProductPurchaseDecision.NotProcessedYet;
		}

		// Wait for player data to load if it's still loading
		await this.waitForPlayerDataToLoad(player);

		// Get player data
		const playerData = await this.dataService.getCache(player);
		if (!playerData) {
			warn(`Player data not loaded for player ${player.Name}, deferring receipt processing`);
			return Enum.ProductPurchaseDecision.NotProcessedYet;
		}

		// Check if receipt has already been processed
		const receiptHistory = playerData.ReceiptHistory ?? [];
		if (receiptHistory.includes(purchaseId)) {
			print(`Receipt ${purchaseId} already processed for player ${player.Name}`);
			return Enum.ProductPurchaseDecision.PurchaseGranted;
		}

		// Get product callback
		const productCallback = this.productCallbacks.get(productId);
		if (!productCallback) {
			warn(`Product ${productId} has no callback set, deferring receipt processing`);
			return Enum.ProductPurchaseDecision.NotProcessedYet;
		}

		// Process the purchase
		let productSuccess = false;
		try {
			productSuccess = productCallback(player, productId);
		} catch (error) {
			warn(`Error when calling product callback for product ${productId}: ${error}`);
			return Enum.ProductPurchaseDecision.NotProcessedYet;
		}

		if (!productSuccess) {
			warn(`Product callback for product ${productId} returned false`);
			return Enum.ProductPurchaseDecision.NotProcessedYet;
		}

		// Add receipt to history
		await this.addReceiptToHistory(player, purchaseId);

		// Wait for data to be saved
		await this.waitForDataSave(player);

		print(`Successfully processed receipt ${purchaseId} for player ${player.Name}`);
		return Enum.ProductPurchaseDecision.PurchaseGranted;
	}

	/**
	 * Adds a receipt to the player's history
	 */
	private async addReceiptToHistory(player: Player, purchaseId: string): Promise<void> {
		const playerData = await this.dataService.getCache(player);
		if (!playerData) {
			return;
		}

		const newData = { ...playerData };
		const receiptHistory = [...(newData.ReceiptHistory ?? [])];

		// Add the new receipt if it's not already there
		if (!receiptHistory.includes(purchaseId)) {
			receiptHistory.push(purchaseId);
		}

		// Trim the receipt history to the maximum length
		while (receiptHistory.size() > this.MAX_RECEIPT_HISTORY) {
			receiptHistory.shift(); // Remove the oldest receipt
		}

		newData.ReceiptHistory = receiptHistory;
		this.dataService.setCache(player, newData);
	}

	/**
	 * Waits for player data to load
	 */
	private async waitForPlayerDataToLoad(player: Player): Promise<void> {
		// Create a race condition between data loading and player leaving
		const dataLoadPromise = new Promise<void>((resolve) => {
			const checkData = async () => {
				const data = await this.dataService.getCache(player);
				if (data) {
					resolve();
				} else {
					task.wait(0.1);
					checkData();
				}
			};
			checkData();
		});

		const playerLeavePromise = new Promise<void>((resolve) => {
			const connection = player.AncestryChanged.Connect((_, parent) => {
				if (parent === undefined) {
					connection.Disconnect();
					resolve();
				}
			});
		});

		// Wait for either data to load or player to leave
		await Promise.race([dataLoadPromise, playerLeavePromise]);
	}

	/**
	 * Waits for data to be saved
	 */
	private async waitForDataSave(player: Player): Promise<void> {
		// In the current implementation, data is immediately saved to cache
		// In a real implementation, you might want to wait for DataStore saves
		// For now, we'll just wait a brief moment to ensure cache is updated
		task.wait(0.1);
	}

	/**
	 * Sets up the MarketplaceService ProcessReceipt callback
	 */
	private setupMarketplaceService(): void {
		MarketplaceService.ProcessReceipt = (receiptInfo: ReceiptInfo) => {
			const playerId = receiptInfo.PlayerId;
			const productId = receiptInfo.ProductId;
			const purchaseId = receiptInfo.PurchaseId;

			// Process receipt asynchronously and return the result
			task.spawn(async () => {
				const result = await this.processReceiptAsync(playerId, productId, purchaseId);
				// Note: In Luau, ProcessReceipt expects a synchronous return
				// This is a simplified version - in practice you might need different handling
				return result;
			});

			// For now, return NotProcessedYet and let the async processing handle it
			// In a real implementation, you might want to cache results or use a different approach
			return Enum.ProductPurchaseDecision.NotProcessedYet;
		};

		print("MarketplaceService ProcessReceipt callback configured");
	}

	/**
	 * Example product callback registration - remove in production
	 */
	public registerExampleProducts(): void {
		// Example: 100 Gold for 10 Robux
		this.registerProductCallback(123456, (player: Player, productId: number) => {
			print(`Processing purchase of product ${productId} for player ${player.Name}`);

			// Add 100 Gold to player
			task.spawn(async () => {
				const playerData = await this.dataService.getCache(player);
				if (playerData) {
					const newData = { ...playerData };
					const currencies = newData.Currencies as unknown as Record<string, number>;
					currencies.Gold = (currencies.Gold ?? 0) + 100;
					this.dataService.setCache(player, newData);
					print(`Added 100 Gold to ${player.Name}`);
				}
			});

			return true;
		});

		// Example: 50 Gems for 25 Robux
		this.registerProductCallback(123457, (player: Player, productId: number) => {
			print(`Processing purchase of product ${productId} for player ${player.Name}`);

			// Add 50 Gems to player
			task.spawn(async () => {
				const playerData = await this.dataService.getCache(player);
				if (playerData) {
					const newData = { ...playerData };
					const currencies = newData.Currencies as unknown as Record<string, number>;
					currencies.Gems = (currencies.Gems ?? 0) + 50;
					this.dataService.setCache(player, newData);
					print(`Added 50 Gems to ${player.Name}`);
				}
			});

			return true;
		});

		print("Example product callbacks registered");
	}
}
